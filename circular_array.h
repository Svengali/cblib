#pragma once

#include "cblib/Base.h"

/*

Template "circular_array"

Fixed max-size array

Head & Tail indexes that wrap around

-------------------------------------

push_back() and pop_front() are your primary accessors
	(that's like add_tail and pop_head or something)

This is actually a Dequeue ; you can push & pop both ends
	if you push_back and pop_front it's a FIFO

all the accessors automatically wrap, the circle is hidden from the client

push_back will never fail, if the buffer is already full it slides the "window"
	so the newest N are in the buffer
	the size is never bigger than maxsize of course

average(begin(),end()) can be used to keep a simple moving average thing

-------------------------------------

NOTE : unlike vector<> I don't destruct the elements that are not active
	technically I should and all, but that's a lot more code and I don't need it
	unused elements aren't released until they're overriden with an assignment
	or the whole contrainer is destructed

-------------------------------------

NOTE : when begin == end there's an ambiguity of whether it's empty or full
	we handle that lazily by never allowing completely full
	thus max_size() is capacity()-1

	it would be better to allow the completely full case, there are various ways to do it

	1. let begin == end mean full and have a special case (begin=end=-1) to mean empty
	2. let begin == end mean empty, and let end == begin + t_capacity mean full

*/

START_CB

//===================================================================================
// iterator that can walk around the wrap

template <class t_entry,int t_capacity> class circular_array_iterator
{
public:
	typedef circular_array_iterator<t_entry,t_capacity> this_type;
	typedef t_entry		value_type;
	typedef t_entry	*	pointer;
	typedef t_entry &	reference;
	typedef int			difference_type;

	circular_array_iterator() : m_index(0), m_data(NULL) { }
	~circular_array_iterator() { }

	circular_array_iterator(t_entry * _data,int _index) : m_data(_data), m_index(_index) { }

	reference operator -> ()
	{
		return m_data+m_index;
	}
	
	reference operator * ()
	{
		return m_data[m_index];
	}

	bool operator == (const this_type & other ) const
	{
		return (m_index == other.m_index && m_data == other.m_data);
	}
	bool operator != (const this_type & other ) const
	{
		return ! (*this == other);
	}

	pointer operator ++ ()
	{
		if ( ++m_index == t_capacity ) m_index = 0;
		return m_data+m_index;
	}
	pointer operator -- ()
	{
		if ( --m_index < 0 ) m_index = t_capacity-1;
		return m_data+m_index;
	}

	pointer operator ++ (int postfix)
	{
		t_entry * ret = m_data+m_index;
		if ( ++m_index == t_capacity ) m_index = 0;
		return ret;
	}
	pointer operator -- (int postfix)
	{
		t_entry * ret = m_data+m_index;
		if ( --m_index < 0 ) m_index = t_capacity-1;
		return ret;
	}
	
	// subtract iterators returns count
	difference_type operator - (const this_type & other ) const
	{
		ASSERT( m_data == other.m_data );
		int diff = m_index - other.m_index;
		if ( diff < 0 ) diff += t_capacity;
		return diff;
	}

private:
	int			m_index;
	t_entry *	m_data;
};

//===================================================================================

template <class t_entry,int t_capacity> class circular_array
{
public:
	//----------------------------------------------------------------------
	// typedefs :
	typedef circular_array<t_entry,t_capacity>	this_type;
	typedef t_entry							value_type;
	typedef t_entry&						reference;
	typedef const t_entry&					const_reference;
	typedef int								size_type;
	typedef circular_array_iterator<t_entry,t_capacity>			iterator;
	typedef circular_array_iterator<const t_entry,t_capacity>	const_iterator;

	// constructors, copy-contructor, and assignment all
	//	default generated by compiler

	inline circular_array() : m_begin(0), m_end(0) { }

	explicit inline circular_array(const t_entry & val) : m_begin(0), m_end(0)
	{
		set_all(val);
	}
	
	template <class input_iterator>
	inline circular_array(const input_iterator first,const input_iterator last) : m_begin(0), m_end(0)
	{
		assign(first,last);
	}
	
	/*
	inline circular_array(const this_type & other)
	{
		assign(other);
	}
	*/
	
	/*
	inline circular_array(const t_entry * data)
	{
		memcpy(m_data,data,sizeof(t_entry)*t_capacity);
	}
	*/
	
	//-------------------------------------------------------------
	// simple accessors :

	// iterator support
	inline iterator			begin()			{ return iterator(m_data,m_begin); }
	inline const_iterator	begin() const	{ return const_iterator(m_data,m_begin); }
	inline iterator			end()			{ return iterator(m_data,m_end); }
	inline const_iterator	end() const		{ return const_iterator(m_data,m_end); }

	// wrap index :
	inline static int		mod(const int i) { return ((i+t_capacity)%t_capacity); }

	// NOTE : at() and bracket() start at m_begin
	//	this lets you do an array-style walk on the valid data, using size() and []

	// at() with range check
	inline reference at(const size_type i)
	{
		ASSERT( i >= 0 && i < size() );
		return m_data[mod(i+m_begin)];
	}
	inline const_reference at(const size_type i) const
	{
		ASSERT( i >= 0 && i < size() );
		return m_data[mod(i+m_begin)];
	}

	// operator[]
	inline reference		operator[](const size_type i)		{ return at(i); }
	inline const_reference	operator[](const size_type i) const { return at(i); }

	// size queries :
	inline bool			empty() const		{ return (m_end == m_begin); }
	inline bool			full() const		{ return size() == max_size(); }
	inline size_type	size() const		{ return mod(m_end - m_begin); }
	inline size_type	max_size() const	{ return t_capacity-1; }
	inline size_type	capacity() const	{ return t_capacity; }

	// clear like a vector (resets it to empty)
	inline void clear()					{ m_begin = m_end = 0; }
	
	// raw data accessor
	// note : use all_data() with capacity() , not max_size !
	//	even when I'm full, one of the entries is not counted
	inline const t_entry * all_data() const	{ return m_data; }
	inline t_entry * all_data()				{ return m_data; }
	
	//----------------------------------------------------------------------
	
	// front() is the oldest element
	inline t_entry & front()	{ ASSERT( ! empty() ); return m_data[m_begin]; }
	inline const t_entry & front() const { ASSERT( ! empty() ); return m_data[m_begin]; }
	
	// back() is the newest element
	inline t_entry & back()	{ ASSERT( ! empty() ); return m_data[mod(m_end-1)]; }
	inline const t_entry & back() const { ASSERT( ! empty() ); return m_data[mod(m_end-1)]; }
		
	// push_back returns if we were full & slid !
	inline bool push_back(const t_entry & e)
	{
		m_data[m_end] = e;
		if ( ++m_end == t_capacity ) m_end = 0;
		if ( m_end == m_begin )
		{
			// wrapped back to begin - keep begin ahead of us!
			if ( ++m_begin == t_capacity ) m_begin = 0;
			return true;
		}
		else
		{
			return false;
		}
	}

	inline const t_entry & pop_back()
	{
		ASSERT( ! empty() );
		if ( --m_end < 0 ) m_end = t_capacity-1;
		return m_data[m_end];
	}
	
	inline const t_entry & pop_front()
	{
		ASSERT( ! empty() );
		const t_entry & ret = m_data[m_begin];
		if ( ++m_begin == t_capacity ) m_begin = 0;
		return ret;
	}
	
	//----------------------------------------------------------------------
	// assign :

	template <class input_iterator>
	void assign(const input_iterator first,const input_iterator last)
	{
		const int count = last - first;
		ASSERT( count <= t_capacity-1 );
		m_begin = 0;
		m_end = count;
		input_iterator it = first;
		for(int i=0;i<count;i++)
		{
			m_data[i] = *it;
			++it;
		}
	}
	
	/*
	template <class input_iterator>
	void assign(const int startIndex,const input_iterator first,const input_iterator last)
	{
		const int count = last - first;
		input_iterator it = first;
		ASSERT( startIndex >= 0 && (startIndex+count) < t_capacity );
		for(int i=0;i<count;i++)
		{
			m_data[startIndex+i] = *it;
			++it;
		}
	}
	
	inline void assign(const this_type & other)
	{
		for(int i=0;i<t_capacity;i++)
		{
			m_data[i] = other.m_data[i];
		}
	}
	
	
	inline void set_all(const value_type & v)
	{
		for(int i=0;i<t_capacity;i++)
		{
			m_data[i] = v;
		}
	}
	*/
	
	//----------------------------------------------------------------------
	
private:
	t_entry	m_data[t_capacity];
	int	m_begin,m_end;
};


/*
template <class t_entry> class circular_array
{
public:
	//----------------------------------------------------------------------
	// typedefs :
	typedef array<t_entry>			this_type;
	typedef t_entry					value_type;
	typedef t_entry*				iterator;
	typedef const t_entry*			const_iterator;
	typedef t_entry&				reference;
	typedef const t_entry&			const_reference;
	typedef int						size_type;

	inline array(int size)	{ m_pData = new t_entry[size]; }
	inline ~array()			{ delete [] m_pData; }

	//----------------------------------------------------------------------
	
private:
	t_entry	* m_pData;
	int		m_size;
};
*/

END_CB
