#pragma once

#include "cblib/Base.h"

/*

Template "circular_array"

Fixed max-size array

Head & Tail indexes that wrap around

-------------------------------------

push_back() and pop_front() are you primary accessors
	(that's like add_tail and pop_head or something)

all the accessors automatically wrap, the circle is hidden from the client

push_back will never fail, if the buffer is already full it slides the "window"
	so the newest N are in the buffer
	the size is never bigger than maxsize of course

average(begin(),end()) can be used to keep a simple moving average thing

-------------------------------------

NOTE : unlike vector<> I don't destruct the elements that are not active
	technically I should and all, but that's a lot more code and I don't need it
	unused elements aren't released until they're overriden with an assignment
	or the whole contrainer is destructed

*/

START_CB

//===================================================================================
// iterator that can walk around the wrap

template <class t_entry,int t_maxsize> class circular_array_iterator
{
public:
	typedef circular_array_iterator<t_entry,t_maxsize> this_type;
	typedef t_entry		value_type;
	typedef t_entry	*	pointer;
	typedef t_entry &	reference;
	typedef int			difference_type;

	circular_array_iterator() : m_index(0), m_data(NULL) { }
	~circular_array_iterator() { }

	circular_array_iterator(t_entry * _data,int _index) : m_data(_data), m_index(_index) { }

	reference operator -> ()
	{
		return m_data+m_index;
	}
	
	reference operator * ()
	{
		return m_data[m_index];
	}

	bool operator == (const this_type & other ) const
	{
		return (m_index == other.m_index && m_data == other.m_data);
	}
	bool operator != (const this_type & other ) const
	{
		return ! (*this == other);
	}

	pointer operator ++ ()
	{
		if ( ++m_index == t_maxsize ) m_index = 0;
		return m_data+m_index;
	}
	pointer operator -- ()
	{
		if ( --m_index == t_maxsize ) m_index = 0;
		return m_data+m_index;
	}

	pointer operator ++ (int)
	{
		t_entry * ret = m_data+m_index;
		if ( ++m_index == t_maxsize ) m_index = 0;
		return ret;
	}
	pointer operator -- (int postfix)
	{
		t_entry * ret = m_data+m_index;
		if ( --m_index == t_maxsize ) m_index = 0;
		return ret;
	}
	
	// subtract iterators returns count
	difference_type operator - (const this_type & other ) const
	{
		ASSERT( m_data == other.m_data );
		int diff = m_index - other.m_index;
		if ( diff < 0 ) diff += t_maxsize;
		return diff;
	}

private:
	int			m_index;
	t_entry *	m_data;
};

//===================================================================================

template <class t_entry,int t_maxsize> class circular_array
{
public:
	//----------------------------------------------------------------------
	// typedefs :
	typedef circular_array<t_entry,t_maxsize>	this_type;
	typedef t_entry							value_type;
	typedef t_entry&						reference;
	typedef const t_entry&					const_reference;
	typedef int								size_type;
	typedef circular_array_iterator<t_entry,t_maxsize>			iterator;
	typedef circular_array_iterator<const t_entry,t_maxsize>	const_iterator;

	// constructors, copy-contructor, and assignment all
	//	default generated by compiler

	__forceinline circular_array() : m_begin(0), m_end(0) { }

	explicit __forceinline circular_array(const t_entry & val) : m_begin(0), m_end(0)
	{
		set_all(val);
	}
	
	template <class input_iterator>
	__forceinline circular_array(const input_iterator first,const input_iterator last) : m_begin(0), m_end(0)
	{
		assign(first,last);
	}
	
	/*
	__forceinline circular_array(const this_type & other)
	{
		assign(other);
	}
	*/
	
	/*
	__forceinline circular_array(const t_entry * data)
	{
		memcpy(m_data,data,sizeof(t_entry)*t_maxsize);
	}
	*/
	
	//-------------------------------------------------------------
	// simple accessors :

	// iterator support
	__forceinline iterator			begin()			{ return iterator(m_data,m_begin); }
	__forceinline const_iterator	begin() const	{ return const_iterator(m_data,m_begin); }
	__forceinline iterator			end()			{ return iterator(m_data,m_end); }
	__forceinline const_iterator	end() const		{ return const_iterator(m_data,m_end); }

	// wrap index :
	__forceinline static int		mod(const int i) { return ((i+t_maxsize)%t_maxsize); }

	// NOTE : at() and bracket() start at m_begin
	//	this lets you do an array-style walk on the valid data, using size() and []

	// at() with range check
	__forceinline reference at(const size_type i)
	{
		ASSERT( i >= 0 && i < size() );
		return m_data[mod(i+m_begin)];
	}
	__forceinline const_reference at(const size_type i) const
	{
		ASSERT( i >= 0 && i < size() );
		return m_data[mod(i+m_begin)];
	}

	// operator[]
	__forceinline reference			operator[](const size_type i)		{ return at(i); }
	__forceinline const_reference	operator[](const size_type i) const { return at(i); }

	// size queries :
	__forceinline bool empty() const			{ return (m_end == m_begin); }
	__forceinline size_type	size() const		{ return mod(m_end - m_begin); }
	__forceinline size_type	max_size() const	{ return t_maxsize; }
	__forceinline size_type	capacity() const	{ return t_maxsize; }

	// clear like a vector (resets it to empty)
	__forceinline void clear()					{ m_begin = m_end = 0; }
	
	// ptr accessor 
	//	(could have an operator t_entry *)
	__forceinline const t_entry * data() const	{ return m_data; }
	__forceinline t_entry * data()				{ return m_data; }
	
	//----------------------------------------------------------------------
	
	__forceinline t_entry & front()	{ ASSERT( ! empty() ); return m_data[m_begin]; }
	__forceinline const t_entry & front() const { ASSERT( ! empty() ); return m_data[m_begin]; }
	
	__forceinline t_entry & back()	{ ASSERT( ! empty() ); return m_data[mod(m_end-1)]; }
	__forceinline const t_entry & back() const { ASSERT( ! empty() ); return m_data[mod(m_end-1)]; }
		
	// push_back returns if we were full & slid !
	__forceinline bool push_back(const t_entry & e)
	{
		m_data[m_end] = e;
		if ( ++m_end == t_maxsize ) m_end = 0;
		if ( m_end == m_begin )
		{
			// wrapped back to begin - keep begin ahead of us!
			if ( ++m_begin == t_maxsize ) m_begin = 0;
			return true;
		}
		else
		{
			return false;
		}
	}

	__forceinline const t_entry & pop_back()
	{
		ASSERT( ! empty() );
		if ( --m_end < 0 ) m_end = t_maxsize-1;
		return m_data[m_end];
	}
	
	__forceinline const t_entry & pop_front()
	{
		ASSERT( ! empty() );
		const t_entry & ret = m_data[m_begin];
		if ( ++m_begin == t_maxsize ) m_begin = 0;
		return ret;
	}
	
	//----------------------------------------------------------------------
	// assign :

	template <class input_iterator>
	void assign(const input_iterator first,const input_iterator last)
	{
		const int count = last - first;
		ASSERT( count <= t_maxsize-1 );
		m_begin = 0;
		m_end = count;
		input_iterator it = first;
		for(int i=0;i<count;i++)
		{
			m_data[i] = *it;
			++it;
		}
	}
	
	/*
	template <class input_iterator>
	void assign(const int startIndex,const input_iterator first,const input_iterator last)
	{
		const int count = last - first;
		input_iterator it = first;
		ASSERT( startIndex >= 0 && (startIndex+count) < t_maxsize );
		for(int i=0;i<count;i++)
		{
			m_data[startIndex+i] = *it;
			++it;
		}
	}
	
	__forceinline void assign(const this_type & other)
	{
		for(int i=0;i<t_maxsize;i++)
		{
			m_data[i] = other.m_data[i];
		}
	}
	
	
	__forceinline void set_all(const value_type & v)
	{
		for(int i=0;i<t_maxsize;i++)
		{
			m_data[i] = v;
		}
	}
	*/
	
	//----------------------------------------------------------------------
	
private:
	t_entry	m_data[t_maxsize];
	int	m_begin,m_end;
};


/*
template <class t_entry> class circular_array
{
public:
	//----------------------------------------------------------------------
	// typedefs :
	typedef array<t_entry>			this_type;
	typedef t_entry					value_type;
	typedef t_entry*				iterator;
	typedef const t_entry*			const_iterator;
	typedef t_entry&				reference;
	typedef const t_entry&			const_reference;
	typedef int						size_type;

	__forceinline array(int size)	{ m_pData = new t_entry[size]; }
	__forceinline ~array()			{ delete [] m_pData; }

	//----------------------------------------------------------------------
	
private:
	t_entry	* m_pData;
	int		m_size;
};
*/

END_CB
