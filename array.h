#pragma once

#include "cblib/Base.h"
#include "cblib/Util.h"

/*

Template "array"

Fixed size, 

*/

START_CB

template <class t_entry,int t_size> class array
{
public:
	//----------------------------------------------------------------------
	// typedefs :
	typedef array<t_entry,t_size>	this_type;
	typedef t_entry					value_type;
	typedef t_entry*				iterator;
	typedef const t_entry*			const_iterator;
	typedef t_entry&				reference;
	typedef const t_entry&			const_reference;
	typedef int						size_type;

	// constructors, copy-contructor, and assignment all
	//	default generated by compiler

	__forceinline array() { }

	explicit __forceinline array(const t_entry & val)
	{
		set_all(val);
	}
	
	/*
	__forceinline array(const this_type & other)
	{
		assign(other);
	}
	*/
	
	template <class input_iterator>
	__forceinline array(const input_iterator first,const input_iterator last)
	{
		assign(first,last);
	}
	
	/*
	__forceinline array(const t_entry * data)
	{
		memcpy(m_data,data,sizeof(t_entry)*t_size);
	}
	*/
	
	//-------------------------------------------------------------
	// simple accessors :

	// iterator support
	__forceinline iterator			begin()			{ return m_data; }
	__forceinline const_iterator	begin() const	{ return m_data; }
	__forceinline iterator			end()			{ return m_data + t_size; }
	__forceinline const_iterator	end() const		{ return m_data + t_size; }

	// at() with range check
	__forceinline reference at(const size_type i)
	{
		ASSERT( i >= 0 && i < t_size );
		return m_data[i];
	}
	__forceinline const_reference at(const size_type i) const
	{
		ASSERT( i >= 0 && i < t_size );
		return m_data[i];
	}

	// operator[]
	__forceinline reference			operator[](const size_type i)		{ return at(i); }
	__forceinline const_reference	operator[](const size_type i) const { return at(i); }

	// size queries :
	//__forceinline size_type	size() const		{ return t_size; }
	__forceinline size_type	max_size() const	{ return t_size; }
	__forceinline size_type	capacity() const	{ return t_size; }

	// ptr accessor 
	//	(could have an operator t_entry *)
	__forceinline const t_entry * data() const	{ return m_data; }
	__forceinline t_entry * data()				{ return m_data; }
	
	//----------------------------------------------------------------------
	// assign :

	template <class input_iterator>
	void assign(const input_iterator first,const input_iterator last)
	{
		const int count = ptr_diff_32( last - first );
		ASSERT( count <= t_size );
		input_iterator it = first;
		for(int i=0;i<count;i++)
		{
			m_data[i] = *it;
			++it;
		}
	}
	
	template <class input_iterator>
	void assign(const int startIndex,const input_iterator first,const input_iterator last)
	{
		const int count = ptr_diff_32( last - first );
		input_iterator it = first;
		ASSERT( startIndex >= 0 && (startIndex+count) < t_size );
		for(int i=0;i<count;i++)
		{
			m_data[startIndex+i] = *it;
			++it;
		}
	}
	
	__forceinline void assign(const this_type & other)
	{
		for(int i=0;i<t_size;i++)
		{
			m_data[i] = other.m_data[i];
		}
	}
	
	__forceinline void set_all(const value_type & v)
	{
		for(int i=0;i<t_size;i++)
		{
			m_data[i] = v;
		}
	}
	
	// CB : bad mis-leading function name! use set_all() instead
	/*
	__forceinline void clear()
	{
		for(int i=0;i<t_size;i++)
		{
			m_data[i] = t_entry();
		}
	}
	*/
	
	//----------------------------------------------------------------------
	
private:
	t_entry	m_data[t_size];
};


/*
template <class t_entry> class array
{
public:
	//----------------------------------------------------------------------
	// typedefs :
	typedef array<t_entry>			this_type;
	typedef t_entry					value_type;
	typedef t_entry*				iterator;
	typedef const t_entry*			const_iterator;
	typedef t_entry&				reference;
	typedef const t_entry&			const_reference;
	typedef int						size_type;

	__forceinline array(int size)	{ m_pData = new t_entry[size]; }
	__forceinline ~array()			{ delete [] m_pData; }

	//----------------------------------------------------------------------
	
private:
	t_entry	* m_pData;
	int		m_size;
};
*/

END_CB
